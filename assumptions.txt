1) If a class extends another class, the class being extended does not have to be defined yet (i.e. if A extends B, B can be defined after A).
2) A field of a class cannot have the same name as the class it is declared in
3) We do not allow function overloading
4) We do not stop semantic analysis after a single error. The error is thrown but semantic analysis continues.
5) No functions, classes or variables cannot be named a reserve word (i.e. you cannot have a class named integer)
6) A variable cannot exceed 30 characters
7) +/- factor must be a real or an integer
8) If we find a mismatched type, we show error, but set the type to be the valid type in order to continue analysis to find more errors in order to give the user insight to all errors
9) An index expression list cannot be longer than one index expression (in variable_access). For exmample, the following is not allowed: a[1,2,3]
10) An actual param can only be an expression, not an expression:expression or expression:expression:expression (because we could not find anything in pascal to discern what that means).
11) As long as the variable access is valid, print statement allows any type
12) Expressions have a field "val" which we are not populating, because we purely doing semantic analysis. We are not actually evaluating expressions.
13) If you try to access a class that does not exist (i.e. a = new fake_class() and there is no "fake_class") than the program will exit immediately.
14) An array indice can only be checked for inbounds if it is a single literal (i.e. a[1]), we felt that evaluating expressions of literals was to be a part of code generation (i.e. a[1+2])
15) You cannot have a class attribute with the same name of the class (other than a constructor), but you can have a local variable (in a class function) with the same name of the class because we are not supporting static functions.
16) We are not supporting recursive structual equivalence.

REMINDERS:
1) If a type denoter is a primitive (TYPE_DENOTER_T_IDENTIFIER) its "name" will correspond to integer, boolean or real and its data will be null
2) If an expression->type is VAR than its an integer (we did this for literals in evaluating array indices)
